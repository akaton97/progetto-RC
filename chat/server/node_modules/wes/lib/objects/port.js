"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Port = exports.MessageSender = void 0;

var _isNil = _interopRequireDefault(require("lodash/isNil"));

var _runtime = _interopRequireDefault(require("mdn-browser-compat-data/webextensions/api/runtime.json"));

var _event = _interopRequireDefault(require("../core/event"));

var _base = _interopRequireDefault(require("../core/base"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * An object containing information about the sender of a message or connection request; this is passed to
 * the {@link Runtime#onMessage} listener.
 * &nbsp
 * It is also a property of {@link Port}, but only in the {@link Port} instance passed into the
 * {@link Runtime#onConnect} or {@link Runtime#onConnectExternal} listeners.
 *
 * @see {@link https://developer.chrome.com/extensions/runtime#type-MessageSender}
 * @see {@link https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/runtime/MessageSender}
 */
var MessageSender =
/*#__PURE__*/
function (_Base) {
  _inherits(MessageSender, _Base);

  function MessageSender(instance) {
    var _this;

    var browser = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, MessageSender);

    _this = _possibleConstructorReturn(this, (MessageSender.__proto__ || Object.getPrototypeOf(MessageSender)).call(this, browser));
    _this._instance = instance;
    return _this;
  }

  _createClass(MessageSender, [{
    key: "$namespace",
    get: function get() {
      return this._instance;
    }
  }, {
    key: "$target",
    get: function get() {
      return this._instance;
    }
    /**
     * The tab which opened the connection. This property will only be defined when the connection was opened
     * from a tab (including content scripts).
     *
     * @see {@link https://developer.chrome.com/extensions/runtime#type-MessageSender}
     * @see {@link https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/runtime/MessageSender}
     *
     * @returns {Tab}
     */

  }, {
    key: "tab",
    get: function get() {
      return this.$property('tab');
    }
    /**
     * The frame that opened the connection. Zero for top-level frames, positive for child frames. This will
     * only be set when tab is set.
     *
     * @see {@link https://developer.chrome.com/extensions/runtime#type-MessageSender}
     * @see {@link https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/runtime/MessageSender}
     *
     * @returns {Number}
     */

  }, {
    key: "frameId",
    get: function get() {
      return this.$property('frameId');
    }
    /**
     * The ID of the extension that sent the message, if the message was sent by an extension. If the sender set
     * an ID explicitly using the applications key in manifest.json, then id will have this value. Otherwise it
     * will have the ID that was generated for the sender.
     * &nbsp
     * Note that in Firefox, before version 54, this value was the extension's internal ID (that is, the UUID
     * that appears in the extension's URL).
     *
     * @see {@link https://developer.chrome.com/extensions/runtime#type-MessageSender}
     * @see {@link https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/runtime/MessageSender}
     *
     * @returns {String}
     */

  }, {
    key: "id",
    get: function get() {
      return this.$property('id');
    }
    /**
     * The URL of the page or frame hosting the script that sent the message.
     * &nbsp
     * If the sender is a script running in an extension page (such as a background page,
     * an options page, or a browser action or page action popup), the URL will be in the form
     * "moz-extension://<extension-internal-id>/path/to/page.html". If the sender is a background script
     * and you haven't included a background page, it will be "moz-extension://<extension-internal-id>/_blank.html".
     * &nbsp
     * If the sender is a script running in a web page (including content scripts as well as normal page scripts),
     * then url will be the web page URL. If the script is running in an iframe, url will be the iframe's URL.
     *
     * @see {@link https://developer.chrome.com/extensions/runtime#type-MessageSender}
     * @see {@link https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/runtime/MessageSender}
     *
     * @returns {String}
     */

  }, {
    key: "url",
    get: function get() {
      return this.$property('url');
    }
    /**
     * The TLS channel ID of the page or frame that opened the connection, if requested by the extension,
     * and if available.
     *
     * @see {@link https://developer.chrome.com/extensions/runtime#type-MessageSender}
     * @see {@link https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/runtime/MessageSender}
     *
     * @returns {String}
     */

  }, {
    key: "tlsChannelId",
    get: function get() {
      return this.$property('tlsChannelId');
    }
  }]);

  return MessageSender;
}(_base.default);
/**
 * A Port object represents one end of a connection between two specific contexts, which can be used to
 * exchange messages.
 * &nbsp
 * One side initiates the connection, using a {@link Runtime#connect} API. This returns a {@link Port} object. The
 * other side listens for connection attempts using an {@link Runtime#onConnect} listener. This is passed a
 * corresponding {@link Port} object.
 * &nbsp
 * Once both sides have {@link Port} objects, they can exchange JSON messages using {@link Port#postMessage} and
 * {@link Port#onMessage}. When they are finished, either end can disconnect using {@link Port#disconnect}, which
 * will generate a {@link Port#onDisconnect} event at the other end, enabling the other end to do any cleanup required.
 * &nbsp
 * You can use this pattern to communicate between:
 * &nbsp
 *  - different parts of your extension (for example, between content scripts and background scripts)
 * &nbsp
 *  - between your extension and a native application running on the user's computer.
 * &nbsp
 *  - between your extension and a different extension
 *
 * @see {@link https://developer.chrome.com/extensions/runtime#type-Port}
 * @see {@link https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/runtime/Port}
 */


exports.MessageSender = MessageSender;
Object.defineProperty(MessageSender, "Title", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 'MessageSender'
});
Object.defineProperty(MessageSender, "Name", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 'runtime.MessageSender'
});
Object.defineProperty(MessageSender, "Prefix", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: false
});
Object.defineProperty(MessageSender, "Compatibility", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: _runtime.default
});
Object.defineProperty(MessageSender, "Standard", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: [// Properties
  'tab', 'id']
});

var Port =
/*#__PURE__*/
function (_Base2) {
  _inherits(Port, _Base2);

  function Port(instance) {
    var _this2;

    var browser = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, Port);

    _this2 = _possibleConstructorReturn(this, (Port.__proto__ || Object.getPrototypeOf(Port)).call(this, browser));
    _this2._instance = instance;
    /**
     * Listener will be called when the other end has called {@link Port#disconnect}. This event will only be
     * fired once for each port. The listener function will be passed the {@link Port} object. If the port was
     * disconnected due to an error, then the {@link Port} argument will contain an error property giving more
     * information about the error.
     * &nbsp
     * Note that on Chrome {@link Port#error} is not supported: instead, use {@link Runtime#lastError} to get
     * the error message.
     *
     * @see {@link https://developer.chrome.com/extensions/runtime#type-Port}
     * @see {@link https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/runtime/Port}
     *
     * @returns {Event} Listener that emits {@link portDisconnectEvent disconnect} events
     */

    _this2.onDisconnect = new _event.default(_this2, 'onDisconnect');
    /**
     * Listener will be called when the other end has sent this port a message. The listener will be passed the
     * JSON object that the other end sent.
     *
     * @see {@link https://developer.chrome.com/extensions/runtime#type-Port}
     * @see {@link https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/runtime/Port}
     *
     * @returns {Event} Listener that emits {@link portMessageEvent message} events
     */

    _this2.onMessage = new _event.default(_this2, 'onMessage');
    return _this2;
  }

  _createClass(Port, [{
    key: "disconnect",

    /**
     * Disconnects a port. Either end can call this when they have finished with the port. It will cause
     * {@link onDisconnect} to be fired at the other end. This is useful if the other end is maintaining
     * some state relating to this port, which can be cleaned up on disconnect. If this port is connected
     * to a native application, this function will close the native application.
     *
     * @see {@link https://developer.chrome.com/extensions/runtime#type-Port}
     * @see {@link https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/runtime/Port}
     */
    value: function disconnect() {
      this.$call('disconnect');
    }
    /**
     *  Send a message to the other end. This takes one argument, which is a JSON object representing the message
     *  to send. It will be delivered to any script listening to the port's {@link Port#onMessage} event, or to
     *  the native application if this port is connected to a native application.
     *
     * @see {@link https://developer.chrome.com/extensions/runtime#type-Port}
     * @see {@link https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/runtime/Port}
     *
     *  @param {Object} message Message
     */

  }, {
    key: "postMessage",
    value: function postMessage(message) {
      this.$call('postMessage', message);
    }
  }, {
    key: "$namespace",
    get: function get() {
      return this._instance;
    }
  }, {
    key: "$target",
    get: function get() {
      return this._instance;
    }
    /**
     * If the port was disconnected due to an error, this will be set to an object with a string property message,
     * giving you more information about the error. See {@link onDisconnect}.
     *
     * @see {@link https://developer.chrome.com/extensions/runtime#type-Port}
     * @see {@link https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/runtime/Port}
     *
     * @returns {Object}
     */

  }, {
    key: "error",
    get: function get() {
      return this.$property('error');
    }
    /**
     * The port's name, defined in the {@link Runtime#connect} or {@link Tabs#connect} call that created it. If
     * this port is connected to a native application, its name is the name of the native application.
     *
     * @see {@link https://developer.chrome.com/extensions/runtime#type-Port}
     * @see {@link https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/runtime/Port}
     *
     * @returns {String}
     */

  }, {
    key: "name",
    get: function get() {
      return this.$property('name');
    }
    /**
     * Contains information about the sender of the message. This property will only be present on ports passed
     * to {@link Runtime#onConnect}/{@link Runtime#onConnectExternal} listeners.
     *
     * @see {@link https://developer.chrome.com/extensions/runtime#type-Port}
     * @see {@link https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/runtime/Port}
     *
     * @returns {MessageSender}
     */

  }, {
    key: "sender",
    get: function get() {
      var instance = this.$property('sender');

      if ((0, _isNil.default)(instance)) {
        return null;
      }

      return new MessageSender(instance, {
        browser: this.$browser
      });
    }
  }]);

  return Port;
}(_base.default);

exports.Port = Port;
Object.defineProperty(Port, "Title", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 'Port'
});
Object.defineProperty(Port, "Name", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 'runtime.Port'
});
Object.defineProperty(Port, "Prefix", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: false
});
Object.defineProperty(Port, "Compatibility", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: _runtime.default
});
Object.defineProperty(Port, "Standard", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: [// Properties
  'name', 'sender', // Events
  'onDisconnect', 'onMessage', // Methods
  'disconnect', 'postMessage']
});