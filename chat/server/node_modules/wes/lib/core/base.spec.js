"use strict";

var _base = _interopRequireDefault(require("./base"));

var _event = _interopRequireDefault(require("./event"));

var _mock = require("../test/mock");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TestCompatibility = {
  webextensions: {
    api: {
      test: {
        missing: {
          __compat: {
            support: {
              chrome: {
                version_added: true
              },
              firefox: {
                version_added: '55'
              }
            }
          }
        },
        value: {
          __compat: {
            support: {
              chrome: {
                version_added: true
              },
              firefox: {
                version_added: '55'
              }
            }
          }
        },
        onEvent: {
          __compat: {
            support: {
              chrome: {
                version_added: true
              },
              firefox: {
                version_added: '55'
              }
            }
          }
        },
        onMissing: {
          __compat: {
            support: {
              chrome: {
                version_added: true
              },
              firefox: {
                version_added: '55'
              }
            }
          }
        },
        onUnsupported: {
          __compat: {
            support: {
              chrome: {
                version_added: false
              },
              firefox: {
                version_added: false
              }
            }
          }
        },
        deprecated: {
          __compat: {
            status: {
              deprecated: true
            },
            support: {
              chrome: {
                version_added: true
              },
              firefox: {
                version_added: '55'
              }
            }
          }
        },
        experimental: {
          __compat: {
            status: {
              experimental: true
            },
            support: {
              chrome: {
                version_added: true
              },
              firefox: {
                version_added: '55'
              }
            }
          }
        },
        error: {
          __compat: {
            support: {
              chrome: {
                version_added: true
              },
              firefox: {
                version_added: '55'
              }
            }
          }
        },
        errorAsync: {
          __compat: {
            support: {
              chrome: {
                version_added: true
              },
              firefox: {
                version_added: '55'
              }
            }
          }
        },
        errorUnknownAsync: {
          __compat: {
            support: {
              chrome: {
                version_added: true
              },
              firefox: {
                version_added: '55'
              }
            }
          }
        },
        success: {
          __compat: {
            support: {
              chrome: {
                version_added: true
              },
              firefox: {
                version_added: '55'
              }
            }
          }
        },
        successAsync: {
          __compat: {
            support: {
              chrome: {
                version_added: true
              },
              firefox: {
                version_added: '55'
              }
            }
          }
        },
        unknownBrowser: {
          __compat: {
            support: {
              unknown: {
                version_added: true
              }
            }
          }
        }
      }
    }
  }
};

var Test =
/*#__PURE__*/
function (_Base) {
  _inherits(Test, _Base);

  function Test() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    _classCallCheck(this, Test);

    _this = _possibleConstructorReturn(this, (Test.__proto__ || Object.getPrototypeOf(Test)).call(this, options));
    _this.onEvent = new _event.default(_this, 'onEvent');
    _this.onMissing = new _event.default(_this, 'onMissing');
    _this.onUnsupported = new _event.default(_this, 'onUnsupported');
    return _this;
  }

  _createClass(Test, [{
    key: "deprecated",
    value: function deprecated() {
      return this.$call('deprecated');
    }
  }, {
    key: "error",
    value: function error() {
      return this.$call('error');
    }
  }, {
    key: "errorAsync",
    value: function errorAsync() {
      return this.$promise('errorAsync');
    }
  }, {
    key: "errorUnknownAsync",
    value: function errorUnknownAsync() {
      return this.$promise('errorUnknownAsync');
    }
  }, {
    key: "experimental",
    value: function experimental() {
      return this.$call('experimental');
    }
  }, {
    key: "missing",
    value: function missing() {
      return this.$call('missing');
    }
  }, {
    key: "success",
    value: function success() {
      return this.$call('success');
    }
  }, {
    key: "successAsync",
    value: function successAsync() {
      return this.$promise('successAsync');
    }
  }, {
    key: "unknownBrowser",
    value: function unknownBrowser() {
      return this.$call('unknownBrowser');
    }
  }, {
    key: "unknownMember",
    value: function unknownMember() {
      return this.$call('unknownMember');
    }
  }, {
    key: "unsupported",
    get: function get() {
      return this.$property('unsupported');
    }
  }, {
    key: "value",
    get: function get() {
      return this.$property('value');
    }
  }]);

  return Test;
}(_base.default);

Object.defineProperty(Test, "Title", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 'Test'
});
Object.defineProperty(Test, "Name", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 'test'
});
Object.defineProperty(Test, "Compatibility", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: TestCompatibility
});
describe('Base', function () {
  describe('Undefined API', function () {
    var test = new Test({
      browser: {
        title: 'Firefox',
        name: 'firefox',
        version: '55.0',
        promises: true,
        namespace: {}
      }
    });
    describe('Events', function () {
      it('should throw an exception on undefined api', function () {
        expect(function () {
          return test.onEvent.addListener(function () {
            return false;
          });
        }).toThrowError(Error, 'test is not available');
      });
    });
    describe('$promise', function () {
      it('should reject with an error on undefined api', function (done) {
        test.errorAsync().then(function () {
          done.fail('Promise wasn\'t rejected');
        }, function (err) {
          expect(err.message).toBe('test is not available');
          done();
        });
      });
    });
    describe('$property', function () {
      it('should throw an exception on undefined api', function () {
        expect(function () {
          return test.value;
        }).toThrowError(Error, 'test is not available');
      });
    });
  });
  describe('Unknown Browser', function () {
    var test = new Test({
      browser: {
        title: 'Test',
        name: 'test',
        version: '55.0',
        promises: true,
        namespace: {
          test: {}
        }
      }
    });
    describe('Events', function () {
      it('should throw an exception on unknown browser', function () {
        expect(function () {
          return test.onEvent.addListener(function () {
            return false;
          });
        }).toThrowError(Error, 'test.onEvent is not available (unknown browser: test)');
      });
    });
    describe('$promise', function () {
      it('should reject with an error on unknown browser', function (done) {
        test.errorAsync().then(function () {
          done.fail('Promise wasn\'t rejected');
        }, function (err) {
          expect(err.message).toBe('test.errorAsync is not available (unknown browser: test)');
          done();
        });
      });
    });
    describe('$property', function () {
      it('should raise an exception on unknown browser', function () {
        expect(function () {
          return test.value;
        }).toThrowError(Error, 'test.value is not available (unknown browser: test)');
      });
    });
  });
  describe('Chrome', function () {
    var onEvent = new _mock.MockListener();
    var runtime = {
      lastError: null
    };
    var test = new Test({
      browser: {
        title: 'Chrome',
        name: 'chrome',
        version: '54.0',
        promises: false,
        namespace: function namespace() {
          return {
            runtime: runtime,
            test: {
              value: 'value',
              onEvent: onEvent,
              deprecated: function deprecated() {
                return 'deprecated';
              },
              experimental: function experimental() {
                return 'experimental';
              },
              success: function success() {
                return 'Success';
              },
              successAsync: function successAsync(callback) {
                callback('Success');
              },
              error: function error() {
                throw new Error('Exception');
              },
              errorAsync: function errorAsync(callback) {
                runtime.lastError = {
                  message: 'Error'
                };
                callback();
              },
              errorUnknownAsync: function errorUnknownAsync(callback) {
                runtime.lastError = {};
                callback();
              },
              unknownBrowser: function unknownBrowser() {
                return 'unknownBrowser';
              },
              unknownMember: function unknownMember() {
                return 'unknownMember';
              }
            }
          };
        }
      }
    });
    describe('Events', function () {
      it('should support addListener(listener)', function (done) {
        test.onEvent.addListener(function (result) {
          expect(result).toBe('event');
          done();
        }); // Emit event

        onEvent.emit('event');
      });
      it('should support hasListener(listener)', function () {
        function listener() {} // Add listener


        test.onEvent.addListener(listener); // Ensure listener has been added

        expect(test.onEvent.hasListener(listener)).toBeTruthy();
      });
      it('should support removeListener(listener)', function () {
        function listener() {} // Add listener


        test.onEvent.addListener(listener); // Ensure listener has been added

        expect(test.onEvent.hasListener(listener)).toBeTruthy(); // Remove listener

        test.onEvent.removeListener(listener); // Ensure listener has been removed

        expect(test.onEvent.hasListener(listener)).toBeFalsy();
      });
      it('should throw an exception on missing event', function () {
        expect(function () {
          return test.onMissing.addListener(function () {
            return false;
          });
        }).toThrowError(Error, 'test.onMissing is not available');
      });
      it('should throw an exception on unsupported browsers', function () {
        expect(function () {
          return test.onUnsupported.addListener(function () {
            return false;
          });
        }).toThrowError(Error, 'test.onUnsupported is not available (not implemented)');
      });
    });
    describe('$call', function () {
      it('should return value', function () {
        expect(test.success()).toBe('Success');
      });
      it('should return value on deprecated function', function () {
        expect(test.deprecated()).toBe('deprecated');
      });
      it('should return value on experimental function', function () {
        expect(test.experimental()).toBe('experimental');
      });
      it('should return value on unknown browser', function () {
        expect(test.unknownBrowser()).toBe('unknownBrowser');
      });
      it('should return value on unknown member', function () {
        expect(test.unknownMember()).toBe('unknownMember');
      });
      it('should throw an exception', function () {
        expect(function () {
          return test.error();
        }).toThrowError(Error, 'Exception');
      });
      it('should throw an exception on missing function', function () {
        expect(function () {
          return test.missing();
        }).toThrowError(Error, 'test.missing is not available');
      });
    });
    describe('$promise', function () {
      it('should return value', function () {
        return test.successAsync().then(function (result) {
          expect(result).toBe('Success');
        });
      });
      it('should reject with error', function (done) {
        test.errorAsync().then(function () {
          done.fail('Promise wasn\'t rejected');
        }, function (err) {
          expect(err.message).toBe('Error');
          done();
        });
      });
      it('should reject with unknown error', function (done) {
        test.errorUnknownAsync().then(function () {
          done.fail('Promise wasn\'t rejected');
        }, function (err) {
          expect(err.message).toBe('Unknown Error');
          done();
        });
      });
    });
    describe('$property', function () {
      it('should return value', function () {
        expect(test.value).toBe('value');
      });
      it('should throw an exception on unsupported browsers', function () {
        expect(function () {
          return test.unsupported;
        }).toThrowError(Error, 'test.unsupported is not available (unknown member)');
      });
    });
  });
  describe('Firefox', function () {
    var onEvent = new _mock.MockListener();
    var runtime = {
      lastError: null
    };
    var test = new Test({
      browser: {
        title: 'Firefox',
        name: 'firefox',
        version: '55.0',
        promises: true,
        namespace: {
          runtime: runtime,
          test: {
            value: 'value',
            onEvent: onEvent,
            success: function success() {
              return 'Success';
            },
            error: function error() {
              throw new Error('Exception');
            },
            successAsync: function successAsync() {
              return Promise.resolve('Success');
            },
            errorAsync: function errorAsync() {
              return Promise.reject(new Error('Error'));
            }
          }
        }
      }
    });
    describe('Events', function () {
      it('should support addListener(listener)', function (done) {
        test.onEvent.addListener(function (result) {
          expect(result).toBe('event');
          done();
        }); // Emit event

        onEvent.emit('event');
      });
      it('should support hasListener(listener)', function () {
        function listener() {} // Add listener


        test.onEvent.addListener(listener); // Ensure listener has been added

        expect(test.onEvent.hasListener(listener)).toBeTruthy();
      });
      it('should support removeListener(listener)', function () {
        function listener() {} // Add listener


        test.onEvent.addListener(listener); // Ensure listener has been added

        expect(test.onEvent.hasListener(listener)).toBeTruthy(); // Remove listener

        test.onEvent.removeListener(listener); // Ensure listener has been removed

        expect(test.onEvent.hasListener(listener)).toBeFalsy();
      });
      it('should throw an exception on missing event', function () {
        expect(function () {
          return test.onMissing.addListener(function () {
            return false;
          });
        }).toThrowError(Error, 'test.onMissing is not available');
      });
      it('should raise an exception on unsupported browsers', function () {
        expect(function () {
          return test.onUnsupported.addListener(function () {
            return false;
          });
        }).toThrowError(Error, 'test.onUnsupported is not available (not implemented)');
      });
    });
    describe('$call', function () {
      it('should return value', function () {
        expect(test.success()).toBe('Success');
      });
      it('should throw an exception', function () {
        expect(function () {
          return test.error();
        }).toThrowError(Error, 'Exception');
      });
      it('should throw an exception on missing function', function () {
        expect(function () {
          return test.missing();
        }).toThrowError(Error, 'test.missing is not available');
      });
    });
    describe('$promise', function () {
      it('should return value', function () {
        return test.successAsync().then(function (result) {
          expect(result).toBe('Success');
        });
      });
      it('should reject with error', function (done) {
        test.errorAsync().then(function () {
          done.fail('Promise wasn\'t rejected');
        }, function (err) {
          expect(err.message).toBe('Error');
          done();
        });
      });
    });
    describe('$property', function () {
      it('should return value', function () {
        expect(test.value).toBe('value');
      });
      it('should raise an exception on unsupported browsers', function () {
        expect(function () {
          return test.unsupported;
        }).toThrowError(Error, 'test.unsupported is not available (unknown member)');
      });
    });
  });
});