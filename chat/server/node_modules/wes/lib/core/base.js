"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _bowser = _interopRequireDefault(require("bowser"));

var _get = _interopRequireDefault(require("lodash/get"));

var _isFunction = _interopRequireDefault(require("lodash/isFunction"));

var _isNil = _interopRequireDefault(require("lodash/isNil"));

var _isString = _interopRequireDefault(require("lodash/isString"));

var _isUndefined = _interopRequireDefault(require("lodash/isUndefined"));

var _deferred = _interopRequireDefault(require("./deferred"));

var _environment = require("./environment");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Base =
/*#__PURE__*/
function () {
  function Base() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    _classCallCheck(this, Base);

    this.$options = _extends({
      browser: _environment.Browser,
      compatibility: null,
      name: null,
      target: null,
      title: null
    }, options || {}); // Retrieve options

    this._browser = this.$options.browser;
    this._compatibility = this.$options.compatibility;
    this._name = this.$options.name;
    this._target = this.$options.target;
    this._title = this.$options.title;
  } // region Browser


  _createClass(Base, [{
    key: "$assertFunction",
    // endregion
    value: function $assertFunction(name) {
      var _$check = this.$check(name),
          path = _$check.path,
          message = _$check.message; // Throw an error if the member doesn't exist


      if (!this.$has(name)) {
        if (!(0, _isNil.default)(path) && !(0, _isNil.default)(message)) {
          throw new Error("".concat(path, " is not available (").concat(message, ")"));
        } else if (!(0, _isNil.default)(path)) {
          throw new Error("".concat(path, " is not available"));
        }

        throw new Error("".concat(name, " is not available"));
      } // Log warning


      if (!(0, _isNil.default)(message)) {
        console.warn("[".concat(path, "] ").concat(message));
      } // Ensure function exists


      if (!(0, _isFunction.default)(this.$target[name])) {
        throw new Error("".concat(name, " is not a function"));
      }
    }
  }, {
    key: "$assertProperty",
    value: function $assertProperty(name) {
      var _$check2 = this.$check(name),
          path = _$check2.path,
          message = _$check2.message; // Throw an error if the member doesn't exist


      if (!(0, _isNil.default)(path) && !(0, _isNil.default)(message)) {
        throw new Error("".concat(path, " is not available (").concat(message, ")"));
      } else if (!(0, _isNil.default)(path)) {
        throw new Error("".concat(path, " is not available"));
      }
    }
  }, {
    key: "$check",
    value: function $check(name) {
      var supportPrefix = '';

      if (this.constructor.Prefix) {
        name = "".concat(this.$name, ".").concat(name);
      } else {
        supportPrefix = "".concat(this.$name, ".");
      } // Build list of paths


      var paths = [];
      var pos = -1;

      while ((pos = name.indexOf('.', pos + 1)) >= 0) {
        paths.push(name.substring(0, pos));
      }

      paths.push(name); // Validate parents

      for (var i = 0; i < paths.length; i++) {
        var path = paths[i];
        var value = (0, _get.default)(this.$namespace, path); // Undefined API

        if ((0, _isNil.default)(value) && i < 1 && this.constructor.Prefix) {
          return {
            path: path,
            message: null
          };
        } // Ignore Root API


        if (i < 1 && this.constructor.Prefix) {
          continue;
        } // Ignore standard members


        var current = path.substring(path.lastIndexOf('.') + 1);

        if (this.$standard.indexOf(current) >= 0) {
          continue;
        } // Retrieve support information


        var _status$support$Get = _extends({
          status: {},
          support: null
        }, (0, _get.default)(this.$support, "".concat(supportPrefix + path, ".__compat"), {})),
            status = _status$support$Get.status,
            support = _status$support$Get.support; // Ensure support information exists


        if ((0, _isNil.default)(support)) {
          if (!(0, _isNil.default)(value)) {
            console.warn("[".concat(path, "] Unknown member"));
            continue;
          }

          return {
            path: path,
            message: 'unknown member'
          };
        } // Ensure browser support information exists


        if ((0, _isNil.default)(support[this.$browser.name])) {
          if (!(0, _isNil.default)(value)) {
            console.warn("[".concat(path, "] Unknown browser: ").concat(this.$browser.name));
            continue;
          }

          return {
            path: path,
            message: "unknown browser: ".concat(this.$browser.name)
          };
        } // Deprecated


        if (status.deprecated) {
          console.warn("[Deprecation] ".concat(path, " is deprecated"));
        }

        if (status.experimental) {
          console.warn("[Experiment] ".concat(path, " is experimental, it may be changed or removed at any time"));
        } // Defined


        if (!(0, _isUndefined.default)(value)) {
          continue;
        } // Check version in support information


        var version_added = support[this.$browser.name].version_added;

        if (version_added === false) {
          return {
            path: path,
            message: 'not implemented'
          };
        }

        if ((0, _isString.default)(version_added) && _bowser.default.compareVersions([this.$browser.version, version_added]) < 0) {
          return {
            path: path,
            message: "requires: ".concat(this.$browser.name, " >= ").concat(version_added)
          };
        } // Not Defined


        return {
          path: path,
          message: null
        };
      }

      return {
        path: null,
        message: null
      };
    }
  }, {
    key: "$exists",
    value: function $exists() {
      return !(0, _isNil.default)(this.$target);
    }
  }, {
    key: "$has",
    value: function $has(name) {
      return this.$exists() && !(0, _isNil.default)((0, _get.default)(this.$target, name));
    }
  }, {
    key: "$hasFunction",
    value: function $hasFunction(name) {
      return this.$has(name) && (0, _isFunction.default)((0, _get.default)(this.$target, name));
    }
  }, {
    key: "$call",
    value: function $call(name) {
      this.$assertFunction(name); // Call target function

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return this.$target[name].apply(this.$target, args);
    }
  }, {
    key: "$promise",
    value: function $promise(name) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      if (this.$browser.promises) {
        try {
          return this.$call.apply(this, [name].concat(args));
        } catch (e) {
          return Promise.reject(e);
        }
      } // Convert callback function to promise


      var deferred = (0, _deferred.default)();
      var self = this;

      function callback() {
        if (!(0, _isNil.default)(self.$lastError)) {
          // Reject promise with `runtime.lastError`
          deferred.reject(new Error(self.$lastError.message || 'Unknown Error'));
          return;
        } // Resolve promise


        deferred.resolve.apply(deferred, arguments);
      }

      try {
        this.$call.apply(this, [name].concat(args, [callback]));
      } catch (e) {
        deferred.reject(e);
      }

      return deferred;
    }
  }, {
    key: "$property",
    value: function $property(name) {
      this.$assertProperty(name); // Return property value

      return this.$target[name];
    }
  }, {
    key: "$browser",
    get: function get() {
      return this._browser;
    },
    set: function set(browser) {
      this._browser = browser;
    } // endregion
    // region Compatibility

  }, {
    key: "$compatibility",
    get: function get() {
      return this._compatibility || this.constructor.Compatibility;
    },
    set: function set(compatibility) {
      this._compatibility = compatibility;
    }
  }, {
    key: "$support",
    get: function get() {
      return (0, _get.default)(this.$compatibility, ['webextensions', 'api']);
    } // endregion
    // region Name

  }, {
    key: "$name",
    get: function get() {
      return this._name || this.constructor.Name;
    },
    set: function set(name) {
      this._name = name;
    } // endregion

  }, {
    key: "$namespace",
    get: function get() {
      if ((0, _isNil.default)(this.$browser)) {
        return {};
      }

      if ((0, _isFunction.default)(this.$browser.namespace)) {
        try {
          this.$browser.namespace = this.$browser.namespace();
        } catch (e) {
          console.warn('Unable to resolve namespace:', e);
        }
      }

      return this.$browser.namespace;
    }
  }, {
    key: "$lastError",
    get: function get() {
      if ((0, _isNil.default)(this.$namespace) || (0, _isNil.default)(this.$namespace.runtime)) {
        return null;
      }

      return this.$namespace.runtime.lastError;
    }
  }, {
    key: "$standard",
    get: function get() {
      return this.constructor.Standard;
    } // region Target

  }, {
    key: "$target",
    get: function get() {
      if (!(0, _isNil.default)(this._target)) {
        return this._target;
      }

      var namespace = this.$namespace;

      if ((0, _isNil.default)(namespace)) {
        return null;
      }

      return namespace[this.$name] || null;
    },
    set: function set(target) {
      this._target = target;
    } // endregion
    // region Title

  }, {
    key: "$title",
    get: function get() {
      return this._title || this.constructor.Title;
    },
    set: function set(title) {
      this._title = title;
    }
  }]);

  return Base;
}();

exports.default = Base;
Object.defineProperty(Base, "Title", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: null
});
Object.defineProperty(Base, "Prefix", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: true
});
Object.defineProperty(Base, "Name", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: null
});
Object.defineProperty(Base, "Compatibility", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: null
});
Object.defineProperty(Base, "Standard", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: []
});