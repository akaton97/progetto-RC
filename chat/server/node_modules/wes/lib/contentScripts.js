"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ContentScriptsCompatibility", {
  enumerable: true,
  get: function get() {
    return _contentScripts.default;
  }
});
exports.default = exports.ContentScripts = exports.RegisteredContentScript = void 0;

var _contentScripts = _interopRequireDefault(require("mdn-browser-compat-data/webextensions/api/contentScripts.json"));

var _isNil = _interopRequireDefault(require("lodash/isNil"));

var _base = _interopRequireDefault(require("./core/base"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * {@link ContentScripts#register} CSS.
 *
 * Object which either has a property named `file`, which is a URL starting at the extension's manifest.json and
 * pointing to a CSS file to register, or a property named `code`, which is some CSS code to register.
 *
 * @see {@link https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/contentScripts/register}
 *
 * @typedef {Object} ContentScripts~RegisterOptionsCSS
 *
 * @property {String} [file] - File Path
 * @property {String} [code] - Code
 */

/**
 * {@link ContentScripts#register} JavaScript.
 *
 * Object which either has a property named `file`, which is a URL starting at the extension's manifest.json and
 * pointing to a JavaScript file to register, or a property named `code`, which is some JavaScript code to register.
 *
 * @see {@link https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/contentScripts/register}
 *
 * @typedef {Object} ContentScripts~RegisterOptionsJS
 *
 * @property {String} [file] - File Path
 * @property {String} [code] - Code
 */

/**
 * {@link ContentScripts#register} Options.
 *
 * Represents the content script to register. It has a similar syntax to the objects in the "content_scripts"
 * manifest key array. The differences are:
 * &nbsp
 * - Property names use camelCase, rather than underscores (for example, `excludeMatches`, not `exclude_matches`)
 * &nbsp
 * - The `js` and `css` properties allow you to register strings as well as URLs, so their syntax has to distinguish
 *   these types.
 *
 * @see {@link https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/contentScripts/register}
 *
 * @typedef {Object} ContentScripts~RegisterOptions
 *
 * @property {String[]} matches           - An array of match patterns.
 * @property {Boolean} [allFrames]        - Inject into all frames matching the specified URL requirements.
 * @property {RegisterOptionsCSS[]} [css] - Array of CSS files/code to inject.
 * @property {String[]} [excludeGlobs]    - An array of strings containing wildcards to exclude.
 * @property {String[]} [excludeMatches]  - An array of match patterns to exclude.
 * @property {String[]} [includeGlobs]    - An array of strings containing wildcards to include.
 * @property {RegisterOptionsJS[]} [js]   - Array of JavaScript files/code to inject.
 * @property {Boolean} [matchAboutBlank]  - Insert the content scripts into blank pages (e.g. "about:blank").
 * @property {String} [runAt]             - When to inject provided `js` (document_start, document_end, document_idle)
 */

/**
 * A {@link RegisteredContentScript} is returned by a call to {@link ContentScripts#register} and represents the
 * content script registered in that call.
 *
 * It defines a single function {@link RegisteredContentScript#unregister}, which can be used to unregister the
 * content script.
 *
 * Note that if this object is destroyed (for example because it goes out of scope) then the content script
 * will be unregistered automatically, so you should keep a reference to this object for as long as you want
 * the content script to stay registered.
 *
 * @see {@link https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/contentScripts/RegisteredContentScript}
 */
var RegisteredContentScript =
/*#__PURE__*/
function (_Base) {
  _inherits(RegisteredContentScript, _Base);

  function RegisteredContentScript(instance) {
    var _this;

    var browser = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, RegisteredContentScript);

    _this = _possibleConstructorReturn(this, (RegisteredContentScript.__proto__ || Object.getPrototypeOf(RegisteredContentScript)).call(this, browser));
    _this._instance = instance;
    return _this;
  }

  _createClass(RegisteredContentScript, [{
    key: "unregister",

    /**
     * Unregister the content script.
     *
     * @see {@link https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/contentScripts/RegisteredContentScript/unregister}
     */
    value: function unregister() {
      this.$call('unregister');
    }
  }, {
    key: "$target",
    get: function get() {
      return this._instance;
    }
  }]);

  return RegisteredContentScript;
}(_base.default);

exports.RegisteredContentScript = RegisteredContentScript;
Object.defineProperty(RegisteredContentScript, "Title", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 'RegisteredContentScript'
});
Object.defineProperty(RegisteredContentScript, "Name", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 'contentScripts.RegisteredContentScript'
});
Object.defineProperty(RegisteredContentScript, "Compatibility", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: _contentScripts.default
});

var ContentScripts =
/*#__PURE__*/
function (_Base2) {
  _inherits(ContentScripts, _Base2);

  function ContentScripts() {
    _classCallCheck(this, ContentScripts);

    return _possibleConstructorReturn(this, (ContentScripts.__proto__ || Object.getPrototypeOf(ContentScripts)).apply(this, arguments));
  }

  _createClass(ContentScripts, [{
    key: "register",

    /**
     * Register content script.
     * &nbsp
     * It accepts one parameter `contentScriptOptions`, which is an object with a similar syntax to the objects in the
     * "content_scripts" manifest key array. The differences are:
     * &nbsp
     *  - Property names use camelCase, rather than underscores (for example, `excludeMatches`, not `exclude_matches`)
     * &nbsp
     *  - The `js` and `css` properties allow you to register strings as well as URLs, so their syntax has to
     *    distinguish these types.
     * &nbsp
     * Note that if this object is destroyed (for example because it goes out of scope) then the content scripts will
     * be unregistered automatically, so you should keep a reference to this object for as long as you want the
     * content scripts to stay registered.
     *
     * @see {@link https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/contentScripts/register}
     *
     * @param {...ContentScripts~RegisterOptions} contentScriptOptions Content Script
     *
     * @returns {Promise} A `Promise` that will be fulfilled with a {@link RegisteredContentScript} object that you
     *                    can use to unregister the content script.
     */
    value: function register(contentScriptOptions) {
      if (!(0, _isNil.default)(contentScriptOptions)) {
        // Set default options
        contentScriptOptions = _extends({
          runAt: 'document_idle'
        }, contentScriptOptions);
      } // Register content script


      return this.$promise('register', contentScriptOptions).then(function (instance) {
        if ((0, _isNil.default)(instance)) {
          return null;
        }

        return new RegisteredContentScript(instance);
      });
    }
  }]);

  return ContentScripts;
}(_base.default);

exports.ContentScripts = ContentScripts;
Object.defineProperty(ContentScripts, "Title", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 'ContentScripts'
});
Object.defineProperty(ContentScripts, "Name", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 'contentScripts'
});
Object.defineProperty(ContentScripts, "Compatibility", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: _contentScripts.default
});
Object.defineProperty(ContentScripts, "Standard", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: ['register']
});

var _default = new ContentScripts();

exports.default = _default;