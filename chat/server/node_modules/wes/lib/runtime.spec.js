"use strict";

var _port = require("./objects/port");

var _mock = require("./test/mock");

var _runtime = require("./runtime");

describe('Runtime', function () {
  describe('Chrome', function () {
    var onBrowserUpdateAvailable = new _mock.MockListener();
    var onConnect = new _mock.MockListener();
    var onConnectExternal = new _mock.MockListener();
    var onInstalled = new _mock.MockListener();
    var onMessage = new _mock.MockListener();
    var onMessageExternal = new _mock.MockListener();
    var onRestartRequired = new _mock.MockListener();
    var onStartup = new _mock.MockListener();
    var onSuspend = new _mock.MockListener();
    var onSuspendCanceled = new _mock.MockListener();
    var onUpdateAvailable = new _mock.MockListener();
    var runtime = new _runtime.Runtime({
      browser: {
        title: 'Chrome',
        name: 'chrome',
        version: '54.0',
        promises: false,
        namespace: {
          runtime: {
            // region Properties
            id: 'wes',
            lastError: null,
            // endregion
            // region Events
            onBrowserUpdateAvailable: onBrowserUpdateAvailable,
            onConnect: onConnect,
            onConnectExternal: onConnectExternal,
            onInstalled: onInstalled,
            onMessage: onMessage,
            onMessageExternal: onMessageExternal,
            onRestartRequired: onRestartRequired,
            onStartup: onStartup,
            onSuspend: onSuspend,
            onSuspendCanceled: onSuspendCanceled,
            onUpdateAvailable: onUpdateAvailable,
            // endregion
            // region Methods
            connect: function connect(extensionId, connectInfo) {
              return {
                name: connectInfo.name,
                sender: {
                  id: extensionId
                }
              };
            },
            connectNative: function connectNative(application) {
              return {
                name: application,
                sender: {
                  id: application
                }
              };
            },
            getBackgroundPage: function getBackgroundPage(callback) {
              return callback('getBackgroundPage');
            },
            getManifest: function getManifest() {
              return 'getManifest';
            },
            getPackageDirectoryEntry: function getPackageDirectoryEntry(callback) {
              return callback('getPackageDirectoryEntry');
            },
            getPlatformInfo: function getPlatformInfo(callback) {
              return callback('getPlatformInfo');
            },
            getURL: function getURL(path) {
              return path;
            },
            openOptionsPage: function openOptionsPage(callback) {
              return callback('openOptionsPage');
            },
            reload: function reload() {
              return true;
            },
            requestUpdateCheck: function requestUpdateCheck(callback) {
              return callback('requestUpdateCheck');
            },
            setUninstallURL: function setUninstallURL(url, callback) {
              return callback(url);
            },
            sendMessage: function sendMessage(extensionId, message, options, callback) {
              return callback({
                extensionId: extensionId,
                message: message,
                options: options
              });
            },
            sendNativeMessage: function sendNativeMessage(application, message, callback) {
              return callback({
                application: application,
                message: message
              });
            } // endregion

          }
        }
      }
    }); // region Properties

    describe('id', function () {
      it('should return value', function () {
        expect(runtime.id).toBe('wes');
      });
    });
    describe('lastError', function () {
      it('should return null', function () {
        expect(runtime.lastError).toBeNull();
      });
    }); // endregion
    // region Events

    describe('onBrowserUpdateAvailable', function () {
      it('supports addListener(listener)', function (done) {
        function listener() {
          done();
        } // Add listener


        runtime.onBrowserUpdateAvailable.addListener(listener); // Emit event

        onBrowserUpdateAvailable.emit();
      });
    });
    describe('onConnect', function () {
      it('supports addListener(listener)', function (done) {
        function listener(port) {
          expect(port).toBe('port');
          done();
        } // Add listener


        runtime.onConnect.addListener(listener); // Emit event

        onConnect.emit('port');
      });
    });
    describe('onConnectExternal', function () {
      it('supports addListener(listener)', function (done) {
        function listener(port) {
          expect(port).toBe('port');
          done();
        } // Add listener


        runtime.onConnectExternal.addListener(listener); // Emit event

        onConnectExternal.emit('port');
      });
    });
    describe('onInstalled', function () {
      it('supports addListener(listener)', function (done) {
        function listener(details) {
          expect(details).toBe('details');
          done();
        } // Add listener


        runtime.onInstalled.addListener(listener); // Emit event

        onInstalled.emit('details');
      });
    });
    describe('onMessage', function () {
      it('supports addListener(listener)', function (done) {
        function listener(message, sender, sendResponse) {
          expect(message).toBe('message');
          expect(sender).toBe('sender');
          expect(sendResponse).toBe('sendResponse');
          done();
        } // Add listener


        runtime.onMessage.addListener(listener); // Emit event

        onMessage.emit('message', 'sender', 'sendResponse');
      });
    });
    describe('onMessageExternal', function () {
      it('supports addListener(listener)', function (done) {
        function listener(message, sender, sendResponse) {
          expect(message).toBe('message');
          expect(sender).toBe('sender');
          expect(sendResponse).toBe('sendResponse');
          done();
        } // Add listener


        runtime.onMessageExternal.addListener(listener); // Emit event

        onMessageExternal.emit('message', 'sender', 'sendResponse');
      });
    });
    describe('onRestartRequired', function () {
      it('supports addListener(listener)', function (done) {
        function listener(reason) {
          expect(reason).toBe('reason');
          done();
        } // Add listener


        runtime.onRestartRequired.addListener(listener); // Emit event

        onRestartRequired.emit('reason');
      });
    });
    describe('onStartup', function () {
      it('supports addListener(listener)', function (done) {
        function listener() {
          done();
        } // Add listener


        runtime.onStartup.addListener(listener); // Emit event

        onStartup.emit();
      });
    });
    describe('onSuspend', function () {
      it('supports addListener(listener)', function (done) {
        function listener() {
          done();
        } // Add listener


        runtime.onSuspend.addListener(listener); // Emit event

        onSuspend.emit();
      });
    });
    describe('onSuspendCanceled', function () {
      it('supports addListener(listener)', function (done) {
        function listener() {
          done();
        } // Add listener


        runtime.onSuspendCanceled.addListener(listener); // Emit event

        onSuspendCanceled.emit();
      });
    });
    describe('onUpdateAvailable', function () {
      it('supports addListener(listener)', function (done) {
        function listener(details) {
          expect(details).toBe('details');
          done();
        } // Add listener


        runtime.onUpdateAvailable.addListener(listener); // Emit event

        onUpdateAvailable.emit('details');
      });
    }); // endregion
    // region Methods

    describe('connect', function () {
      it('should return a wrapped Port', function () {
        var port = runtime.connect('wes', {
          name: 'test'
        });
        expect(port instanceof _port.Port).toBeTruthy();
        expect(port.name).toBe('test');
        expect(port.sender instanceof _port.MessageSender).toBeTruthy();
        expect(port.sender.id).toBe('wes');
      });
      it('should return null if no port is returned', function () {
        var runtime = new _runtime.Runtime({
          browser: {
            title: 'Chrome',
            name: 'chrome',
            version: '54.0',
            promises: false,
            namespace: {
              runtime: {
                connect: function connect() {
                  return null;
                }
              }
            }
          }
        });
        expect(runtime.connect('wes', {
          name: 'test'
        })).toBeNull();
      });
    });
    describe('connectNative', function () {
      it('should return a wrapped Port', function () {
        var port = runtime.connectNative('wes');
        expect(port instanceof _port.Port).toBeTruthy();
        expect(port.name).toBe('wes');
        expect(port.sender instanceof _port.MessageSender).toBeTruthy();
        expect(port.sender.id).toBe('wes');
      });
      it('should return null if no port is returned', function () {
        var runtime = new _runtime.Runtime({
          browser: {
            title: 'Chrome',
            name: 'chrome',
            version: '54.0',
            promises: false,
            namespace: {
              runtime: {
                connectNative: function connectNative() {
                  return null;
                }
              }
            }
          }
        });
        expect(runtime.connectNative('wes')).toBeNull();
      });
    });
    describe('getBackgroundPage', function () {
      it('should return promise', function () {
        return runtime.getBackgroundPage().then(function (result) {
          expect(result).toBe('getBackgroundPage');
        });
      });
    });
    describe('getBrowserInfo', function () {
      it('should reject with unsupported error', function (done) {
        runtime.getBrowserInfo().then(function () {
          done.fail('Promise wasn\'t rejected');
        }, function (err) {
          expect(err.message).toBe('runtime.getBrowserInfo is not available (not implemented)');
          done();
        });
      });
    });
    describe('getManifest', function () {
      it('should return value', function () {
        expect(runtime.getManifest()).toBe('getManifest');
      });
    });
    describe('getPackageDirectoryEntry', function () {
      it('should return promise', function () {
        return runtime.getPackageDirectoryEntry().then(function (result) {
          expect(result).toBe('getPackageDirectoryEntry');
        });
      });
    });
    describe('getPlatformInfo', function () {
      it('should return promise', function () {
        return runtime.getPlatformInfo().then(function (result) {
          expect(result).toBe('getPlatformInfo');
        });
      });
    });
    describe('getURL', function () {
      it('should return value', function () {
        expect(runtime.getURL('path')).toBe('path');
      });
    });
    describe('openOptionsPage', function () {
      it('should return promise', function () {
        return runtime.openOptionsPage().then(function (result) {
          expect(result).toBe('openOptionsPage');
        });
      });
    });
    describe('reload', function () {
      it('should call function', function () {
        runtime.reload();
      });
    });
    describe('requestUpdateCheck', function () {
      it('should return promise', function () {
        return runtime.requestUpdateCheck().then(function (result) {
          expect(result).toBe('requestUpdateCheck');
        });
      });
    });
    describe('sendMessage', function () {
      it('should return promise', function () {
        return runtime.sendMessage('extensionId', 'message', {
          includeTlsChannelId: true
        }).then(function (result) {
          expect(result).toEqual({
            extensionId: 'extensionId',
            message: 'message',
            options: {
              includeTlsChannelId: true
            }
          });
        });
      });
    });
    describe('sendNativeMessage', function () {
      it('should return promise', function () {
        return runtime.sendNativeMessage('application', 'message').then(function (result) {
          expect(result).toEqual({
            application: 'application',
            message: 'message'
          });
        });
      });
    });
    describe('setUninstallURL', function () {
      it('should return promise', function () {
        return runtime.setUninstallURL('url').then(function (result) {
          expect(result).toBe('url');
        });
      });
    }); // endregion
  });
  describe('Firefox', function () {
    var onConnect = new _mock.MockListener();
    var onConnectExternal = new _mock.MockListener();
    var onInstalled = new _mock.MockListener();
    var onMessage = new _mock.MockListener();
    var onMessageExternal = new _mock.MockListener();
    var onStartup = new _mock.MockListener();
    var onUpdateAvailable = new _mock.MockListener();
    var runtime = new _runtime.Runtime({
      browser: {
        title: 'Firefox',
        name: 'firefox',
        version: '54.0',
        promises: true,
        namespace: {
          runtime: {
            // region Properties
            id: 'wes',
            lastError: null,
            // endregion
            // region Events
            onConnect: onConnect,
            onConnectExternal: onConnectExternal,
            onInstalled: onInstalled,
            onMessage: onMessage,
            onMessageExternal: onMessageExternal,
            onStartup: onStartup,
            onUpdateAvailable: onUpdateAvailable,
            // endregion
            // region Methods
            connect: function connect(extensionId, connectInfo) {
              return {
                name: connectInfo.name,
                sender: {
                  id: extensionId
                }
              };
            },
            connectNative: function connectNative(application) {
              return {
                name: application,
                sender: {
                  id: application
                }
              };
            },
            getBackgroundPage: function getBackgroundPage() {
              return Promise.resolve('getBackgroundPage');
            },
            getBrowserInfo: function getBrowserInfo() {
              return Promise.resolve('getBrowserInfo');
            },
            getManifest: function getManifest() {
              return 'getManifest';
            },
            getPlatformInfo: function getPlatformInfo() {
              return Promise.resolve('getPlatformInfo');
            },
            getURL: function getURL(path) {
              return path;
            },
            openOptionsPage: function openOptionsPage() {
              return Promise.resolve('openOptionsPage');
            },
            reload: function reload() {
              return true;
            },
            setUninstallURL: function setUninstallURL(url) {
              return Promise.resolve(url);
            },
            sendMessage: function sendMessage(extensionId, message, options) {
              return Promise.resolve({
                extensionId: extensionId,
                message: message,
                options: options
              });
            },
            sendNativeMessage: function sendNativeMessage(application, message) {
              return Promise.resolve({
                application: application,
                message: message
              });
            } // endregion

          }
        }
      }
    }); // region Properties

    describe('id', function () {
      it('should return value', function () {
        expect(runtime.id).toBe('wes');
      });
    });
    describe('lastError', function () {
      it('should return null', function () {
        expect(runtime.lastError).toBeNull();
      });
    }); // endregion
    // region Events

    describe('onBrowserUpdateAvailable', function () {
      it('should throw an error from addListener(listener)', function () {
        expect(function () {
          return runtime.onBrowserUpdateAvailable.addListener(function () {
            return false;
          });
        }).toThrowError(Error, 'runtime.onBrowserUpdateAvailable is not available (not implemented)');
      });
    });
    describe('onConnect', function () {
      it('supports addListener(listener)', function (done) {
        function listener(port) {
          expect(port).toBe('port');
          done();
        } // Add listener


        runtime.onConnect.addListener(listener); // Emit event

        onConnect.emit('port');
      });
    });
    describe('onConnectExternal', function () {
      it('supports addListener(listener)', function (done) {
        function listener(port) {
          expect(port).toBe('port');
          done();
        } // Add listener


        runtime.onConnectExternal.addListener(listener); // Emit event

        onConnectExternal.emit('port');
      });
    });
    describe('onInstalled', function () {
      it('supports addListener(listener)', function (done) {
        function listener(details) {
          expect(details).toBe('details');
          done();
        } // Add listener


        runtime.onInstalled.addListener(listener); // Emit event

        onInstalled.emit('details');
      });
    });
    describe('onMessage', function () {
      it('supports addListener(listener)', function (done) {
        function listener(message, sender, sendResponse) {
          expect(message).toBe('message');
          expect(sender).toBe('sender');
          expect(sendResponse).toBe('sendResponse');
          done();
        } // Add listener


        runtime.onMessage.addListener(listener); // Emit event

        onMessage.emit('message', 'sender', 'sendResponse');
      });
    });
    describe('onMessageExternal', function () {
      it('supports addListener(listener)', function (done) {
        function listener(message, sender, sendResponse) {
          expect(message).toBe('message');
          expect(sender).toBe('sender');
          expect(sendResponse).toBe('sendResponse');
          done();
        } // Add listener


        runtime.onMessageExternal.addListener(listener); // Emit event

        onMessageExternal.emit('message', 'sender', 'sendResponse');
      });
    });
    describe('onRestartRequired', function () {
      it('should throw an error from addListener(listener)', function () {
        expect(function () {
          return runtime.onRestartRequired.addListener(function () {
            return false;
          });
        }).toThrowError(Error, 'runtime.onRestartRequired is not available (not implemented)');
      });
    });
    describe('onStartup', function () {
      it('supports addListener(listener)', function (done) {
        function listener() {
          done();
        } // Add listener


        runtime.onStartup.addListener(listener); // Emit event

        onStartup.emit();
      });
    });
    describe('onSuspend', function () {
      it('should throw an error from addListener(listener)', function () {
        expect(function () {
          return runtime.onSuspend.addListener(function () {
            return false;
          });
        }).toThrowError(Error, 'runtime.onSuspend is not available (not implemented)');
      });
    });
    describe('onSuspendCanceled', function () {
      it('should throw an error from addListener(listener)', function () {
        expect(function () {
          return runtime.onSuspendCanceled.addListener(function () {
            return false;
          });
        }).toThrowError(Error, 'runtime.onSuspendCanceled is not available (not implemented)');
      });
    });
    describe('onUpdateAvailable', function () {
      it('supports addListener(listener)', function (done) {
        function listener(details) {
          expect(details).toBe('details');
          done();
        } // Add listener


        runtime.onUpdateAvailable.addListener(listener); // Emit event

        onUpdateAvailable.emit('details');
      });
    }); // endregion
    // region Methods

    describe('connect', function () {
      it('should return a wrapped Port', function () {
        var port = runtime.connect('wes', {
          name: 'test'
        });
        expect(port instanceof _port.Port).toBeTruthy();
        expect(port.name).toBe('test');
        expect(port.sender instanceof _port.MessageSender).toBeTruthy();
        expect(port.sender.id).toBe('wes');
      });
      it('should return null if no port is returned', function () {
        var runtime = new _runtime.Runtime({
          browser: {
            title: 'Chrome',
            name: 'chrome',
            version: '54.0',
            promises: false,
            namespace: {
              runtime: {
                connect: function connect() {
                  return null;
                }
              }
            }
          }
        });
        expect(runtime.connect('wes', {
          name: 'test'
        })).toBeNull();
      });
    });
    describe('connectNative', function () {
      it('should return a wrapped Port', function () {
        var port = runtime.connectNative('wes');
        expect(port instanceof _port.Port).toBeTruthy();
        expect(port.name).toBe('wes');
        expect(port.sender instanceof _port.MessageSender).toBeTruthy();
        expect(port.sender.id).toBe('wes');
      });
      it('should return null if no port is returned', function () {
        var runtime = new _runtime.Runtime({
          browser: {
            title: 'Chrome',
            name: 'chrome',
            version: '54.0',
            promises: false,
            namespace: {
              runtime: {
                connectNative: function connectNative() {
                  return null;
                }
              }
            }
          }
        });
        expect(runtime.connectNative('wes')).toBeNull();
      });
    });
    describe('getBackgroundPage', function () {
      it('should return promise', function () {
        return runtime.getBackgroundPage().then(function (result) {
          expect(result).toBe('getBackgroundPage');
        });
      });
    });
    describe('getBrowserInfo', function () {
      it('should return promise', function () {
        return runtime.getBrowserInfo().then(function (result) {
          expect(result).toBe('getBrowserInfo');
        });
      });
    });
    describe('getManifest', function () {
      it('should return value', function () {
        expect(runtime.getManifest()).toBe('getManifest');
      });
    });
    describe('getPackageDirectoryEntry', function () {
      it('should return promise', function (done) {
        runtime.getPackageDirectoryEntry().then(function () {
          done.fail('Promise wasn\'t rejected');
        }, function (err) {
          expect(err.message).toBe('runtime.getPackageDirectoryEntry is not available (not implemented)');
          done();
        });
      });
    });
    describe('getPlatformInfo', function () {
      it('should return promise', function () {
        return runtime.getPlatformInfo().then(function (result) {
          expect(result).toBe('getPlatformInfo');
        });
      });
    });
    describe('getURL', function () {
      it('should return value', function () {
        expect(runtime.getURL('path')).toBe('path');
      });
    });
    describe('openOptionsPage', function () {
      it('should return promise', function () {
        return runtime.openOptionsPage().then(function (result) {
          expect(result).toBe('openOptionsPage');
        });
      });
    });
    describe('reload', function () {
      it('should call function', function () {
        runtime.reload();
      });
    });
    describe('requestUpdateCheck', function () {
      it('should return promise', function (done) {
        runtime.requestUpdateCheck().then(function () {
          done.fail('Promise wasn\'t rejected');
        }, function (err) {
          expect(err.message).toBe('runtime.requestUpdateCheck is not available (not implemented)');
          done();
        });
      });
    });
    describe('sendMessage', function () {
      it('should return promise', function () {
        return runtime.sendMessage('extensionId', 'message', {
          includeTlsChannelId: true
        }).then(function (result) {
          expect(result).toEqual({
            extensionId: 'extensionId',
            message: 'message',
            options: {
              includeTlsChannelId: true
            }
          });
        });
      });
    });
    describe('sendNativeMessage', function () {
      it('should return promise', function () {
        return runtime.sendNativeMessage('application', 'message').then(function (result) {
          expect(result).toEqual({
            application: 'application',
            message: 'message'
          });
        });
      });
    });
    describe('setUninstallURL', function () {
      it('should return promise', function () {
        return runtime.setUninstallURL('url').then(function (result) {
          expect(result).toBe('url');
        });
      });
    }); // endregion
  });
});